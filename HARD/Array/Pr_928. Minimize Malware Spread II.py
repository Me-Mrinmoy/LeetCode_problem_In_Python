from collections import deque

class Solution(object):
    def minMalwareSpread(self, graph, initial):
        n = len(graph)
        initial_sorted = sorted(initial)

        # Build adjacency list once (faster to iterate neighbors than scanning row each time)
        neighbors = [[j for j in range(n) if graph[i][j]] for i in range(n)]

        best_node = initial_sorted[0]
        best_infected = float('inf')

        for removed in initial_sorted:
            # visited marks nodes that become infected (or the removed node so it's ignored)
            visited = [False] * n
            visited[removed] = True  # removed node is out of network

            q = deque()
            infected = 0

            # multi-source enqueue all other initially infected nodes
            for u in initial:
                if u == removed:
                    continue
                if not visited[u]:
                    visited[u] = True
                    infected += 1
                    q.append(u)

            # BFS spread
            while q:
                u = q.popleft()
                for v in neighbors[u]:
                    if not visited[v]:
                        visited[v] = True
                        infected += 1
                        q.append(v)

            # choose the node that minimizes infected; tie-break by smaller index
            if infected < best_infected:
                best_infected = infected
                best_node = removed

            # can't get better than 0 (or 1 if at least one initial remains), optional early exit:
            if best_infected == 0:
                break

        return best_node
